package app

import (
	"os"
	"sync"

	"github.com/handcraftdev/blackhole/internal/core"
	"github.com/handcraftdev/blackhole/internal/core/config"
	"github.com/handcraftdev/blackhole/internal/core/process"
	"go.uber.org/zap"
)

// Service interface that all services must implement
type Service interface {
	Start() error
	Stop() error
	Name() string
	Health() bool
}

// Application represents the main blackhole application
type Application struct {
	// Core components
	logger         *zap.Logger
	configManager  *config.ConfigManager
	processManager *process.Orchestrator
	
	// Service registry
	services       map[string]Service
	servicesMutex  sync.RWMutex
	
	// Synchronization
	mu       sync.RWMutex
	doneCh   chan struct{}
	isActive bool
}

// NewApplication creates a new application instance
func NewApplication() *Application {
	// Create a default logger
	logger, err := zap.NewProduction()
	if err != nil {
		// If we can't create a logger, panic - we need logging
		panic("failed to initialize logger: " + err.Error())
	}
	
	// Create a config manager
	configManager := config.NewConfigManager()
	
	// Return new application
	return &Application{
		logger:        logger,
		configManager: configManager,
		doneCh:        make(chan struct{}),
		services:      make(map[string]Service),
	}
}

// RegisterService registers a service with the application
func (a *Application) RegisterService(service Service) error {
	a.servicesMutex.Lock()
	defer a.servicesMutex.Unlock()
	
	a.services[service.Name()] = service
	a.logger.Info("Service registered", zap.String("service", service.Name()))
	return nil
}

// Start starts the application
func (a *Application) Start() error {
	a.mu.Lock()
	if a.isActive {
		a.mu.Unlock()
		return nil // Already started
	}
	a.isActive = true
	a.mu.Unlock()

	a.logger.Info("Starting Blackhole application")
	
	// Initialize process manager
	orchestrator, err := process.NewOrchestrator(a.configManager, process.WithLogger(a.logger))
	if err != nil {
		return err
	}
	a.processManager = orchestrator
	
	// Start the orchestrator
	if err := orchestrator.Start(); err != nil {
		return err
	}
	
	// Start all enabled services
	if err := orchestrator.StartAll(); err != nil {
		a.logger.Warn("Some services failed to start", zap.Error(err))
		// Continue with the services that did start
	}
	
	a.logger.Info("Blackhole application started successfully")
	return nil
}

// Stop stops the application
func (a *Application) Stop() error {
	a.mu.Lock()
	if !a.isActive {
		a.mu.Unlock()
		return nil // Already stopped
	}
	a.isActive = false
	a.mu.Unlock()

	a.logger.Info("Stopping Blackhole application")
	
	// Stop the orchestrator if it exists
	if a.processManager != nil {
		if err := a.processManager.Stop(); err != nil {
			a.logger.Error("Error while stopping orchestrator", zap.Error(err))
			// Continue with shutdown anyway
		}
	}
	
	// Close the done channel
	close(a.doneCh)
	
	a.logger.Info("Blackhole application stopped")
	return nil
}

// GetProcessManager returns the process manager
func (a *Application) GetProcessManager() core.ProcessManager {
	return a.processManager
}

// GetConfigManager returns the configuration manager
func (a *Application) GetConfigManager() core.ConfigManager {
	return a.configManager
}

// GetService returns a service by name
func (a *Application) GetService(name string) (Service, bool) {
	a.servicesMutex.RLock()
	defer a.servicesMutex.RUnlock()
	
	service, exists := a.services[name]
	return service, exists
}